<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Skeptical Learning - advice</title><link href="/" rel="alternate"></link><link href="/feeds/advice.atom.xml" rel="self"></link><id>/</id><updated>2018-10-22T10:20:00+11:00</updated><entry><title>A/B testing / Bandit Methods</title><link href="/blog/ab-testing-bandit-methods" rel="alternate"></link><published>2018-10-22T10:20:00+11:00</published><updated>2018-10-22T10:20:00+11:00</updated><author><name>Varun Nayyar</name></author><id>tag:None,2018-10-22:/blog/ab-testing-bandit-methods</id><summary type="html">&lt;p&gt;This is a short article, primarily full of resources.&lt;/p&gt;
&lt;h2&gt;A/B testing&lt;/h2&gt;
&lt;p&gt;I must start posting Evan Miller's articles on the subject which I consider a fantastic resource in this area. Additionally, it's also really easy &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://www.evanmiller.org/how-not-to-run-an-ab-test.html"&gt;How not to run an A/B test&lt;/a&gt; - never end an A/B test …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;This is a short article, primarily full of resources.&lt;/p&gt;
&lt;h2&gt;A/B testing&lt;/h2&gt;
&lt;p&gt;I must start posting Evan Miller's articles on the subject which I consider a fantastic resource in this area. Additionally, it's also really easy &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://www.evanmiller.org/how-not-to-run-an-ab-test.html"&gt;How not to run an A/B test&lt;/a&gt; - never end an A/B test before it's allocated run time.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.evanmiller.org/sequential-ab-testing.html"&gt;Sequential A/B testing&lt;/a&gt; - How to run an A/B test that allows for stopping early without ruining results. &lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.evanmiller.org/bayesian-ab-testing.html"&gt;Bayesian A/B testing&lt;/a&gt; - a Bayesian approach that allows one to 'peek'&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Additionally, this article on &lt;a href="https://www.evanmiller.org/the-low-base-rate-problem.html"&gt;statstical power&lt;/a&gt; is also something worth reading as it touches on assessing significance when your click rates are low - basically the lower the success rate is, the more samples you need to ensure that you've reached significance.&lt;/p&gt;
&lt;h3&gt;A/B Testing Summary + Skepticism&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;All the approaches of A/B testing use the same tech backend. The Sequential and Bayesian approaches allow for checking the results partway through, so there is an expectation that you can check on your results every so often, and maybe even automate this part&lt;/li&gt;
&lt;li&gt;Traditional A/B testing is the most robust approach - if you use an early stop version, you run the risk of catching significance on a certain day. For example, testing a greeting that uses "Monday" performs better on monday and might show significance that wouldn't be ther when run over a period of a week.&lt;/li&gt;
&lt;li&gt;Generally speaking, the bayesian approach is preferred over sequential testing. Or at least has found more wide adoption. This is primarily because you still need to choose a sample size at the beginning, a restriction not present in the bayesian approach.&lt;/li&gt;
&lt;li&gt;There is a lot of debate over traditional a/b testing vs bayesian methodology, and the basic answer is that it's not that important. If you want robustness, go traditional, if you expect a big lift, go bayesian so you can stop the experiment as soon as you're confident in the results.&lt;/li&gt;
&lt;li&gt;The traditional A/B testing is much better known, is easier to implement and is less likely to confuse someone than a bayesian approach. Frequentist results are easier to misinterpret than Bayesian results, but bayesian results are harder to arrive at.&lt;/li&gt;
&lt;li&gt;Bayesian methods are more computationally intensive than the equivalent frequentist statistics and has fewer well known implementations. &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href="https://conversionxl.com/blog/bayesian-frequentist-ab-testing/"&gt;This article&lt;/a&gt; runs through the various differences in much greater detail.
&lt;a href="https://conversionxl.com/blog/12-ab-split-testing-mistakes-i-see-businesses-make-all-the-time/"&gt;And this article&lt;/a&gt; lists a few other common errors common in A/B testing in real life, with a very heavy web bias. 
A/B testing does exist in other scenarios (traditionally in use of new medical treatments), but the Web has been a much more fertile ground for turning this up to 11. The original ethical concerns of stopping an effective medical trial early have only been approached in the internet age.&lt;/p&gt;
&lt;h2&gt;Bandit Methods&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://lilianweng.github.io/lil-log/2018/01/23/the-multi-armed-bandit-problem-and-its-solutions.html"&gt;Bandit methods&lt;/a&gt; are the other side of the coin which basically approach the problem of trying a few different methods, seeing the success of one over the other and presenting the more successful one more often. &lt;/p&gt;
&lt;p&gt;More precisely, we set a parameter epsilon which is an indication of our exploration rate that we reduce over the period of our testing (a week for example). We then choose a random page if epsilon &amp;gt; random() otherwise, we serve our best page. &lt;/p&gt;
&lt;p&gt;Bandit methods are a similar response to traditional A/B testing, the question of regret. When you have a better method (say a donation webpage) that's outperforming your old one, you lose a lot of money for each day you run the A/B test. Also, if you run a lot of A/B tests, setting up and analysing at the end is always a pain, can you set you&lt;/p&gt;
&lt;h3&gt;Bandt Summary + Skepticism&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;A more involved tech stack. While A/B testing simply records result of web A/B interaction, bandit methods need to store result of the interaction and then work out which webpage to show based on past results. Unlike a simple random call to determine which page to show, the code at the delivery layer is a bit more involved. This is likely the big issue&lt;/li&gt;
&lt;li&gt;Bandit methods are quite fragile - they rely on instant feedback to adjust the probability of returning the best value. Email campaigns or conversions that are non-instant break the fundamental assumptions of bandit methods and can lead to it acting quite erratic.&lt;/li&gt;
&lt;li&gt;Similarly to above, a certain day of the week can push a bandit method into prime position that stays at the top for a while. Contrastingly, a bandit method won't realise that a certain page is more effective on certain days. &lt;/li&gt;
&lt;li&gt;Bandit methods need careful consideration of setup and exploration. Since the exploitation tends to favour one over the other, using it tends to result in a massive imbalance, and you can converge to non-ideal answers.&lt;/li&gt;
&lt;li&gt;Knowledge of the distributions involved allows you to put a bayesian spin on the answer. In particular tracking the upper confidence bound is generally a better idea since you get more certainty the more you exploit and you include potential value in your equations&lt;/li&gt;
&lt;li&gt;Bandit methods don't give you inference - the imbalance means you don't ever have a sample size that's big enough in both categories to give you the inference you're after. At the end of a bandit run, you're unlikely to be completely sure you've found the best answer, though you can try various strategies to ensure the certainty&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Bandit vs A/B&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://conversionxl.com/blog/bandit-tests/"&gt;This post&lt;/a&gt; is a fantastic resource on this and does a much better job than I could on the question.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;The basic conclusion is that Bandit's when done well are powerful approaches, but also require an organisation to be completely behind the system. &lt;/li&gt;
&lt;li&gt;Considerations from A/B tests (running for a week at minimum, public holidays) need to be applied to Bandit methods too.&lt;/li&gt;
&lt;li&gt;Drawbacks of bandit methods, mainly need for instant feedback, should disqualify these methods when instant feedback is not possible.&lt;/li&gt;
&lt;li&gt;Bandit methods are great way to run continuous a/b tests without the need to involve a Data Scientist. Designers can upload new pages and can see if the pages are working better.&lt;/li&gt;
&lt;li&gt;Bandit methods are less complex to scale than an A/B/n test.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Finally it doesn't really matter. Bandit methods are a natural evolution for an org that has realised the value of A/B tests and is constantly running tests. It's unlikely you'd go from no testing to bandit methods, and A/B tests are a very robust way to approach this problem, perfect for a beginner in this space.&lt;/p&gt;</content><category term="skeptical"></category><category term="ds"></category><category term="advice"></category><category term="ab"></category><category term="bandit"></category></entry><entry><title>Skeptical Resume Screening</title><link href="/blog/skeptical-resume-screening" rel="alternate"></link><published>2018-09-03T10:20:00+10:00</published><updated>2018-09-03T10:20:00+10:00</updated><author><name>Varun Nayyar</name></author><id>tag:None,2018-09-03:/blog/skeptical-resume-screening</id><summary type="html">&lt;p&gt;Like all enthusiastic idiots, I thought it would be a great idea to help in interviewing and resume screening. Unfortunately, this meant that I ended up reading a lot of resumes and started to develop my own model of what was important, from education to portfolios and things in between …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Like all enthusiastic idiots, I thought it would be a great idea to help in interviewing and resume screening. Unfortunately, this meant that I ended up reading a lot of resumes and started to develop my own model of what was important, from education to portfolios and things in between. I assume you're going to have an exhaustive interview process anyway, so resume screening really should be about finding people with potential, rather than scouring for potential.&lt;/p&gt;
&lt;p&gt;We all have biases, I've done this work in many fields now so I think my bias is relatively even, though my background (math/engineering degree, started down PhD path, but walked away) is still fairly biased.&lt;/p&gt;
&lt;h2&gt;Education/Background&lt;/h2&gt;
&lt;p&gt;I have strong belief that a degree with quantitative backing is vital. Degrees like Maths, Physics, Engineering, Computer Science and Econometrics are generally degrees that form the foundations for a good data scientist. Most degrees don't just teach foundations, but also mould the way a person thinks. My Maths degree makes me more analytical, rigorous and skeptical, while my engineering degree was focused on getting results no matter what hacks were needed. And it's important to have a wide range of skills and make-up in your team as you'll encounter various problems that require different kinds of thinking and approaches. Having a team with no educational diversity results in very narrow thinking and is something you should seek to avoid.&lt;/p&gt;
&lt;h3&gt;The Good&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Computer Science Majors - these are probably the more dominant group in Data Science today. Primarily because there is a large amount of programming skill required to be able to DS and a comp sci major already has that down pat. They also have strong-ish maths skills, as computer science deals with a lot of discrete maths so they have a strong foundation to build on. Very good employees to have at any stage of your company. They have a lot of value at the beginning of DS in a company as they have enough software experience to get you off the ground and as your process improves, the amount of code required increases exponentially. &lt;/li&gt;
&lt;li&gt;Stats/Maths/Physics (Science) Majors - less dominant, but equally important, they form the other side of the coin, in that they're much stronger in the foundations of maths, but tend to have less programming skill. They're usually very well versed in different approaches and bring a degree of rigour and skepticism that's required to build great models. Again useful at all stages, as they bring simple approaches to bear in the beginning, but also tap into more advanced techniques as required and usually tend to stay on top of what's happening in the field.&lt;/li&gt;
&lt;li&gt;Engineering majors - Engineers are a halfway optimisation between comp sci and science in this field, though many of them don't have a full background to be useful straight away. However, they generally make fantastic project managers, as they tend to be results driven and very aware of pitfalls in planning and also fantastic at turning problems into data science questions. In many ways, this unlocks a lot of value from your team and are ideal people to have if you feel like your DS team gets stuck and flounders a lot. &lt;/li&gt;
&lt;li&gt;Economics majors - (I haven't had a lot of exposure) What these majors tend to provide is a lot of lateral thinking, strong attempts to understand the domain that they're trying to improve, and an understanding of how to present DS ideas to non-technical people well.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Again, these are more tendencies than specifics, there'll be comp sci majors with better mathematical foundations than most maths/stats majors and maths/stats majors with better programming skill than most comp sci majors.&lt;/p&gt;
&lt;p&gt;I love cross majors, comp sci/stats tend to give the best of both worlds in terms of foundations.&lt;/p&gt;
&lt;h3&gt;The Skepticism&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;Comp Sci - are almost always obsessed with Neural Nets of all kinds. They also tend to lack a strong statistical base and many regressions and Bayesian approaches mean nothing to them. They come with strong biases and might need to unlearn a lot of them and this can be an issue. They rarely bring any skepticism to the table and are almost always overly confident about the performance of a model of theirs. There is also diminishing returns in comp sci skill in DS, the open source community puts together efficient implementations, so past a certain point, programming skill is less necessary than software architecture skill.&lt;/li&gt;
&lt;li&gt;Maths/Stats - many can barely program and require a lot of training to be useful in this field. If you're unlucky, they'll even consider programming beneath them. And they're severely constrained by their need for rigour and are very dour about their results, which means good models they build might go unnoticed. Require very careful management&lt;/li&gt;
&lt;li&gt;Engineers - tend to be middle of the road in both mathy and comp sci skills and don't really push your team forward in many ways. Over reliance on short term results can mean sacrificing longer term goals which they don't see as well. May also not get any respect from the comp sci/math majors&lt;/li&gt;
&lt;li&gt;Economics majors - they also come with awful mathematics and programming skills, and are unlikely to have the insight as they were probably stars in their own fields.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Higher Education (PhDs)&lt;/h2&gt;
&lt;p&gt;Overall, I'm mixed. PhD &amp;gt; undergrad, but PhD = Undergrad + 3 years experience. I think PhDs tend to be overrated, but are a safer bet than untested undergrad. I think experience + degree/PhD is the best combination.&lt;/p&gt;
&lt;h3&gt;The Good&lt;/h3&gt;
&lt;p&gt;PhDs mean that the person who did them is very self-directed, self motivated and has the ability to learn by themselves, all of which are great features to have in an employee. Assuming a quantitative PhD, they likely have very strong skills in this area that are likely to be of instant use to you. Additionally, given that PhDs are usually from the top undergrads, you have a guarantee that they're generally more intelligent. PhDs tend to be people you need if you're on the cutting edge and are very good for raising the ceiling of your teams ability.&lt;/p&gt;
&lt;h3&gt;The Skepticism&lt;/h3&gt;
&lt;p&gt;The main problem is that a PhD doesn't really tell me that much about a person's ability to be an employee. Research and corporate environments are very different and success in one doesn't always translate. The PhD tends to be a very specific and sharp area, &lt;a href="http://matt.might.net/articles/phd-school-in-pictures/"&gt;see this comic&lt;/a&gt; and while they've got more general skill, they're not necessarily much better than an undergrad, especially if you expect to have a bunch of different problems to solve. Additionally, the PhDs tend to be very top heavy the ones that are intelligent and have the ability to transfer skills, are likely ones to stick around in academia too. Basically a PhD applying is likely more intelligent than an undergrad, but you also know that they probably weren't the best of their cohort.&lt;/p&gt;
&lt;h2&gt;Portfolio/Github&lt;/h2&gt;
&lt;p&gt;I used to love these things, but I now realise that it's quite a biased way to hire. The presence does make me go from a maybe to a yes, but the lack of one doesn't make me go no.&lt;/p&gt;
&lt;h3&gt;The Good&lt;/h3&gt;
&lt;p&gt;It's always fantastic to see a Github profile and portfolio - you instantly get an idea of the candidate's programming ability and a portfolio gives you an insight into how they think and what models they're familiar with. PR to public repos are strongly indicative of an ability to work in a corporate DS environment, and proof they've solved a real world problem with a DS technique is more evidence. &lt;/p&gt;
&lt;p&gt;Additionally, this shows curiosity, which I consider a huge thing in a person. A curious person can be depended on to keep learning, improving and getting better. I argue a curious person with limited skill has more potential than a skilled by uninterested person. &lt;/p&gt;
&lt;h3&gt;The Skepticism&lt;/h3&gt;
&lt;p&gt;Github and Portfolio's are very biased towards comp sci type majors, either studying or working in a small firm/startup. &lt;/p&gt;
&lt;p&gt;As stated before, there is a diminishing return for programming skill, but there is also a high bar to entry. This means people who have the ability to download, parse and write some code to run a simple model are more likely to have portfolio's than someone with the ability to conceptualise more complicated models, but need help to see that through. Now requirements might differ, but programming is an easier skill to lean than thinking mathematically. &lt;/p&gt;
&lt;p&gt;Despite pytorch being written by facebook, tensorflow by google, nearly all the blogs I read on how to use it have been written by people working for a .io or someone at university. As I read somewhere (and have experienced myself), working in a leading tech firm is like working in an alternate reality - they've made developments they've kept secret, but as the open source community has put out their own approaches, the rest of industry has fallen in line of the path of the open source implementations. Which means google and facebook employees have hard skills almost entirely based on non-open tech stacks and while they have ideas on how to solve the problem, they are unfamiliar with the prevailing packages and thus don't really have much to write about. Even startups that came up in the time between tensorflow and pytorch probably wouldn't write blogs about pytorch, again for the same reasoning.&lt;/p&gt;
&lt;h2&gt;Experience&lt;/h2&gt;
&lt;p&gt;This is only a good thing, so I'm not going to split sections up, but instead point out things I like to see&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Versatility: If their experience shows a wide variety of problems being solved, that's good, because it shows they're not overly biased to one methodology and they have a wide exposure to methods to solve problems and a very strong sense of good process as approached by many places.&lt;/li&gt;
&lt;li&gt;Soft Skills: Hard skills are very rarely transferable. A lot of hard skill in a company is getting used to the way things are done and replicating that skill. Look at things like process changes, picking up things quickly, testing methodology and &lt;/li&gt;
&lt;li&gt;Curiosity: Hard to generally tell from a resume, but curiosity is a thing that makes for excellent employees. You can tell a lack of it relatively easy if the resume looks cookie cutter.&lt;/li&gt;
&lt;li&gt;Company profile: elite companies in the resume are always strong indicators of success. There are many niche industries out there that are also elite so do make sure to do your research. I also tend to prefer experience in small-mid companies as this usually results in a much better overall skillset, while people in large companies tend to be overspecialised, though this can cut both ways.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;My Red Flags&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Poorly Presented Resume: This job has a huge amount of communication and if the applicant can't put together a resume that looks reasonable and clean, this might be a problem.&lt;/li&gt;
&lt;li&gt;Matlab: This is a personal peeve of mine, but Matlab on your resume indicates a lack of curiosity in the applicant. I used matlab (it's still one of my top linkedin skills for some reason) and didn't like it, so I sought better alternatives. If you haven't done that, chances are you're not going to have insight into your work.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Overall, none of the areas can be taken in isolation. A non quant degree but 10 years in google DS mean something, while a PhD in Comp Sci and 5 years building apps builds another story. It also depends on your company, whether you have a large profile and get good applicants, or you need to interview to find diamonds in the rough.&lt;/p&gt;
&lt;p&gt;More than anything else, be aware about your stereotypes and biases in hiring when looking at a resume. We tend to want to hire people like us/fit the company profile and so tech heavy companies hire coders who can do maths, while many consultancies hire problem solvers who can code and do maths, quant firms hire maths guys and try and teach them to code. This sometimes work, but diversity of thought is always important, I &lt;/p&gt;</content><category term="skeptical"></category><category term="ds"></category><category term="advice"></category><category term="interview"></category><category term="resume"></category></entry></feed>