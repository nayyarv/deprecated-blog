<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Bayesian Learning - interview</title><link href="https://nayyarv.github.io/" rel="alternate"></link><link href="https://nayyarv.github.io/feeds/interview.atom.xml" rel="self"></link><id>https://nayyarv.github.io/</id><updated>2019-08-26T10:20:00+10:00</updated><entry><title>Some Technical Interview Questions</title><link href="https://nayyarv.github.io/blog/some-technical-interview-questions" rel="alternate"></link><published>2019-08-26T10:20:00+10:00</published><updated>2019-08-26T10:20:00+10:00</updated><author><name>Varun Nayyar</name></author><id>tag:nayyarv.github.io,2019-08-26:/blog/some-technical-interview-questions</id><summary type="html">&lt;p&gt;I recently had the chance/misfortune to attend a lot of ML interviews and it's kind of given me a little insight into the industry as it stands right now. I wanted to share the way I interview and why I choose those questions. These questions are mostly ideal for â€¦&lt;/p&gt;</summary><content type="html">&lt;p&gt;I recently had the chance/misfortune to attend a lot of ML interviews and it's kind of given me a little insight into the industry as it stands right now. I wanted to share the way I interview and why I choose those questions. These questions are mostly ideal for a small/mid size DS/ML tech firm - smaller companies can't afford as much specialisation and niche areas of research will have people coming in quite unfamiliar that you don't want to reject unecessarily (a la Google) due to a much weaker recruitment pool.&lt;/p&gt;
&lt;p&gt;This article really only applies to final interviews of candidates, but some ideas might bleed over to screening rounds too.&lt;/p&gt;
&lt;h2&gt;The Rationale&lt;/h2&gt;
&lt;p&gt;At a smaller firm, the job title in ML is best described as Research Engineer. You need to have feet in both research and software since you need to be able to implement your ideas as well as roll out to production. You tend to get two different types here - maths majors who've learned to program well and programmers who've picked up maths. The first group tend to be PhD's (or dropouts) while the second group tend to be self taught in ML. &lt;/p&gt;
&lt;h2&gt;Considerations&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;It has to be about the fundamentals/basics &lt;ul&gt;
&lt;li&gt;You can't ask anything specific to your domain - it's likely to be niche, your candidate is unlikely to have skill in your particular area, and even if he's coming from a competitor, the way things done are so different, it's tricky to assume any level of skill. Fundamentally, you can't select for specific knowledge since either the interviewer is not proficient enough or the candidate isn't. &lt;/li&gt;
&lt;li&gt;Seeing if they stay up to date is really difficult since they may, but in an area you're not familiar in. And if they haven't read the latest paper in your space, that's not on them either.&lt;/li&gt;
&lt;li&gt;You're trying to work out if they can learn new things. You're testing for intelligence, not specific knowledge.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Not everyone has experience with every algorithm. You can't ask someone about the details of a neural net if they've never trained one. Not having experience with torch/tensorflow is meaningless, most people never need to train neural nets and shouldn't, so it shouldn't be held against them. I call this the KL divergence criterion - measuring someone's skill should be independent of the interviewer's interests and skills.&lt;/li&gt;
&lt;li&gt;It should give them a chance to go into depth. In order to be about the basics without being a quiz, it should allow the person to dive as deep as they are able. This gives them a chance to show off what they know. Because of this, I don't necessarily like the idea of 5 independent 45 minute interviews. I think it's a good idea to have the technical interview run a bit longer and reduce the number of interviews. &lt;/li&gt;
&lt;li&gt;You should decide on a rubric before you go into the interviewer. This can be modified as you get more experience, but reasoning about how marks should be allocated reduces your bias and also helps getting feedback from colleagues. It also forces you to think about how questions&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Cardinal Sins&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Quizzes. Your interview questions should be good even when doing it open book. Questions like this are of limited benefit and tend to be good for someone fresh out of a data science bootcamp.&lt;ul&gt;
&lt;li&gt;Vanishing gradients in Neural Nets&lt;/li&gt;
&lt;li&gt;What are support vectors in SVMs&lt;/li&gt;
&lt;li&gt;The difference between Boosting and Bagging
Furthermore, these questions impinge on my principle of expecting full coverage of questions and not being good open book questions. They serve well as a screeners, but should be abandoned early.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Pure software interviews&lt;ul&gt;
&lt;li&gt;Data Structures and algorithms are not good ways to interview ML engineers. There is some benefit, but a very large part of ML engineering doesn't go that low level since much of it is done in higher level languages that have plenty of abstractions. Most software engineers never really go into much depth in terms of Data Structures, most ML engineers even less. You'll reject many for no reason&lt;/li&gt;
&lt;li&gt;These questions are easily gameable. Seeing the study guides for google et al, it doesn't seem like something you can compete with. Leetcode has nearly every interview and this has resulted in degeneracy in the interview process.&lt;/li&gt;
&lt;li&gt;These questions have high false positive rates - many rely on tricks or familiarity. It's worth a simple one  as a fizzbuzz test but nothing more.&lt;/li&gt;
&lt;li&gt;Software interviews are best combined with real world programming. I had an interview which asked me to implement malloc and free - this was a terrible interview for my skillset, but something that would be good to ask a software engineer. Another example was a key value DB that also kept the time values so you could get historical records too.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Brain teasers&lt;ul&gt;
&lt;li&gt;This is very rarely a good idea - it can be a proxy feature of what you're looking for, but it's a very noisy way of getting that out. This was tried in discarded in the 2000s by most software firms.&lt;/li&gt;
&lt;li&gt;Again, these are likely to select people who've seen the questions and also those who are lucky. It's also heavily dependent on the interviewers giving good hints. &lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;General Principles&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Tailor the interview to the candidate - ask them which areas of ML they're good at, or provide a few questions and give them a choice. For ML, you don't want to check their weaknesses, you want to test their strengths.&lt;ul&gt;
&lt;li&gt;I've considered asking an interviewee what they'd prefer to be tested on and ask them to prep it and test them on that instead of giving a very broad interview.&lt;/li&gt;
&lt;li&gt;If they have a publically available project, I think it would be a good idea to ask them to review it and write up a presentation on it. This could be a good way to determine their understanding of their core topic and comfort with presenting.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Take Home Interview Aside&lt;ul&gt;
&lt;li&gt;this should be used judiciously. If a person has no experience and no portfolio, it's fair to ask. Less so for experienced candidates since they'll have other offers and not want to waste time on your interview.&lt;/li&gt;
&lt;li&gt;Provide choice so the person gets to play to their strengths&lt;/li&gt;
&lt;li&gt;Ensure the person speaks with someone on the ML team before asking for the assignment. If the person is clearly competent, it may not be necessary and might chase away competent people. It also gives them an indication of fit so they can choose to spend the time on the process&lt;/li&gt;
&lt;li&gt;Offer payment at market rate (i.e. if you're paying 100k pay 50/hr). This prevents you from setting stupidly long assignments, shows committment to the candidate and provides a hard time limit. You should get this time limit from asking other members of the team to do this question and estimate time spent on it.&lt;/li&gt;
&lt;li&gt;Provide a marking rubric - allow the candidate to understand what you value. It also ensures consistency across reviewers and if universities do so, so should you.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Workshop your interview - testing on a person currently working for the company is a good idea. You get an idea of how long the interview will take (add a multiplier for interview nerves) and if it's an interview that would pass your current colleagues. You should discuss interview questions with colleagues extensively and try it out on a couple of candidates with low confidence to check it's performaance in real world scenarios before moving it into the standard rotation.&lt;/li&gt;
&lt;li&gt;These interviews require more work, but in a competitive market, a good interviewing experience can really help you stand out. They also give you a chance to get someone's best performance instead of the relatively noisy current interview style.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;My Questions (in progress)&lt;/h2&gt;
&lt;h3&gt;The Elevator Problem&lt;/h3&gt;
&lt;p&gt;Problem solving in a vacuum. No ML needed, but may bias towards Comp Sci majors since it is algorithmic. I like it since it requires one to state a few assumptions, come to a few simple insights and decide on it.&lt;/p&gt;
&lt;h4&gt;Question Statement&lt;/h4&gt;
&lt;p&gt;A residential building has 20 floors and 3 elevators. The current elevator algorithm chooses the nearest elevator and sends it to the requesting floor. You can assume that elevators are almost always used one at a time (i.e. there is never more than 1 requester and while he/she is in motion, no one else requests an elevator). &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Describe some scenarios which cause subpar performance with this algorithm.&lt;ul&gt;
&lt;li&gt;Hint: consider what happens in the morning and the evenings during the week&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Can you suggest some improvements to the algorithm to minimise waiting time for the residents&lt;ul&gt;
&lt;li&gt;Note: the optimal solution is in research, so make sure they only try to come up with a good algorithm&lt;/li&gt;
&lt;li&gt;Describe how your considerations would change for an office building&lt;/li&gt;
&lt;li&gt;How would you evaluate your new algorithm?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;Notes&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Tests Problem Solving ability and taking poorly defined questions and reasoning about them&lt;/li&gt;
&lt;li&gt;Stress to candidates that this is not an ML question, just something more deterministic&lt;/li&gt;
&lt;li&gt;Many problems require simple solutions - recognising that is a good sign&lt;/li&gt;
&lt;li&gt;Meta level considerations (feasability of having ML in elevators) is usually a good sign. &lt;/li&gt;
&lt;li&gt;Extra bonus - simulate some data and then evaluate the improvements. Also tests coding ability&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Design a Neural Net&lt;/h3&gt;
&lt;p&gt;Good mix of software systems design and ML considerations. I really like this since neural nets are so simple but have a few design decisions. Additionally, almost every ML person will have some understanding of how Neural Nets work and this requires very little prior knowledge. This should be done open book. &lt;/p&gt;
&lt;p&gt;There are many ML points to consider that allow for an in depth look into their ability to reason. It's also not some annoying string search algorithm that is very gameable. &lt;/p&gt;
&lt;h4&gt;Question Statement&lt;/h4&gt;
&lt;p&gt;We live in a world where torch and tensorflow don't exist. You want to build your own neural net using just numpy. It should&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Support an arbitrary number of layers&lt;/li&gt;
&lt;li&gt;Have Fully Connected Layers and TanH activations out of the box&lt;/li&gt;
&lt;li&gt;Do SGD for optimisation&lt;/li&gt;
&lt;li&gt;(Bonus 1) custom learning rate&lt;/li&gt;
&lt;li&gt;(Bonus 2) Momentum SGD - this can be tough&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can assume&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;No GPU acceleration&lt;/li&gt;
&lt;li&gt;Infinite RAM &lt;/li&gt;
&lt;li&gt;No RNNs&lt;/li&gt;
&lt;li&gt;data is a single (shortish) vector&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Notes&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Longish interview, systems design esque. &lt;/li&gt;
&lt;li&gt;This can double as a behavioural interview and see how they respond to criticism and suggestions&lt;/li&gt;
&lt;li&gt;Arbitrary changes should be proposed to see how they handle design. &lt;ul&gt;
&lt;li&gt;Dual Fully Connected Layers (W1 @ x2 + W2 @ x2) should be an interesting mixup&lt;/li&gt;
&lt;li&gt;Skip Layers?&lt;/li&gt;
&lt;li&gt;How would they implement Transfer learning&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;This can be adapted to implementing a particular simple algorithm that they're familiar with. Doing Bayesian Linear regression via MCMC achieves a very similar outcome for someone who's familiar with Bayesian methodology&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Many points of discussion, a few below:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;How&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;initialise&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;why&lt;/span&gt; &lt;span class="nv"&gt;ones&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;zeros&lt;/span&gt; &lt;span class="nv"&gt;is&lt;/span&gt; &lt;span class="nv"&gt;bad&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;weight&lt;/span&gt; &lt;span class="nv"&gt;matrices&lt;/span&gt;.
    &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;I&lt;/span&gt;.&lt;span class="nv"&gt;e&lt;/span&gt;. &lt;span class="nv"&gt;backprop&lt;/span&gt; &lt;span class="nv"&gt;is&lt;/span&gt; &lt;span class="nv"&gt;slow&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;imbalanced&lt;/span&gt; 
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;Shape&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;state&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;FC&lt;/span&gt; &lt;span class="nv"&gt;layer&lt;/span&gt;. &lt;span class="nv"&gt;Column&lt;/span&gt; &lt;span class="nv"&gt;major&lt;/span&gt; &lt;span class="nv"&gt;vs&lt;/span&gt; &lt;span class="nv"&gt;row&lt;/span&gt; &lt;span class="nv"&gt;major&lt;/span&gt;? 
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;How&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;save&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;x&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;backward&lt;/span&gt; &lt;span class="nv"&gt;pass&lt;/span&gt;? &lt;span class="nv"&gt;Design&lt;/span&gt; &lt;span class="nv"&gt;choice&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;How&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;implement&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;optimiser&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="k"&gt;Do&lt;/span&gt; &lt;span class="nv"&gt;they&lt;/span&gt; &lt;span class="nv"&gt;write&lt;/span&gt; &lt;span class="nv"&gt;tests&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;can&lt;/span&gt; &lt;span class="nv"&gt;they&lt;/span&gt; &lt;span class="nv"&gt;check&lt;/span&gt; &lt;span class="nv"&gt;it&lt;/span&gt; &lt;span class="nv"&gt;works&lt;/span&gt;
    &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;A&lt;/span&gt; &lt;span class="nv"&gt;set&lt;/span&gt; &lt;span class="nv"&gt;of&lt;/span&gt; &lt;span class="nv"&gt;tests&lt;/span&gt; &lt;span class="nv"&gt;is&lt;/span&gt; &lt;span class="nv"&gt;very&lt;/span&gt; &lt;span class="nv"&gt;good&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;see&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;they&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="s"&gt;re considering how it&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="nv"&gt;s&lt;/span&gt; &lt;span class="nv"&gt;going&lt;/span&gt; &lt;span class="nv"&gt;to&lt;/span&gt; &lt;span class="nv"&gt;be&lt;/span&gt; &lt;span class="nv"&gt;used&lt;/span&gt;
    &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;Checking&lt;/span&gt; &lt;span class="nv"&gt;that&lt;/span&gt; &lt;span class="nv"&gt;training&lt;/span&gt; &lt;span class="nv"&gt;a&lt;/span&gt; &lt;span class="nv"&gt;net&lt;/span&gt; &lt;span class="nv"&gt;on&lt;/span&gt; &lt;span class="k"&gt;random&lt;/span&gt; &lt;span class="nv"&gt;data&lt;/span&gt; &lt;span class="nv"&gt;reduces&lt;/span&gt; &lt;span class="nv"&gt;loss&lt;/span&gt; &lt;span class="nv"&gt;is&lt;/span&gt; &lt;span class="nv"&gt;good&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;suggest&lt;/span&gt; &lt;span class="nv"&gt;providing&lt;/span&gt; &lt;span class="nv"&gt;loss&lt;/span&gt; &lt;span class="nv"&gt;function&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;derivatives&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="nv"&gt;speed&lt;/span&gt;&lt;span class="ss"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="nv"&gt;Discussion&lt;/span&gt; &lt;span class="nv"&gt;on&lt;/span&gt; &lt;span class="nv"&gt;numerical&lt;/span&gt; &lt;span class="nv"&gt;considerations&lt;/span&gt; &lt;span class="ss"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;i&lt;/span&gt;.&lt;span class="nv"&gt;e&lt;/span&gt;. &lt;span class="nv"&gt;logs&lt;/span&gt; &lt;span class="nv"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;small&lt;/span&gt; &lt;span class="nv"&gt;numbers&lt;/span&gt;, &lt;span class="nv"&gt;requiring&lt;/span&gt; &lt;span class="nv"&gt;the&lt;/span&gt; &lt;span class="nv"&gt;combination&lt;/span&gt; &lt;span class="ss"&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Further Questions&lt;/h2&gt;
&lt;p&gt;To be added&lt;/p&gt;
&lt;p&gt;Implementing ML algorithms is a great exercise - it doesn't have to be a neural net, but they can choose an algorithm they're most familiar with. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;- A simple tree algorithm is another great one. 
- MCMC is another algorithm that is super easy to implement and can be tested on anscombe&amp;#39;s quartet
- Linear Regression is a bit too simple, so make sure they add more diagnositcs and I would suggest using tro
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;ML &amp;amp; DS today&lt;/h2&gt;
&lt;p&gt;Opinion&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ML/Research Scientist - Almost exclusive to large organisations, these are commonly Postdocs with strong publication records who've left academia because of the insane competition for tenure and ply their trade on complex problems. Since large companies tend to have a lot of infrastructure and support, these people tend to come in very specialised since the scale and depth of these problems is very different. For example, the Google Assistant is world class (especially with varying accents) and this level of performance is very research intensive.&lt;/li&gt;
&lt;li&gt;ML Engineer (Large Company) - The scale at large companies results in a split of the ML roles into scientist (Above) and engineer. Most of this is focussed on things like data pipelines, clusters, implementing algorithms from scientists, scaling up to a cluster or even working with scientists to adapt algorithm for scale. This is much closer to a pure SWE than an ML engineer at a smaller company.&lt;/li&gt;
&lt;li&gt;ML (Small/Mid company) - specialisation is not really something the company needs and requires. R&amp;amp;D, ops and deployment are tightly knit and there is a significant need to share duties. Problems are less cutting edge and the scale is much smaller. Full datasets will likely fit into RAM so large scale sharding and infra is significantly less important here. The role of engineer and scientist tends to blend together here with the job best being described as a research engineer. There is expectation to develop the algorithms and deploy them as well as maintain all the infrastructure necessary. This is a tricky position to hire for, since it's very rare to find high level skill in research and software. This merged skillsets are conversely less valuable in a large company, so make sure to not copy and paste requirements - being open is your best bet for finding a good fit.&lt;/li&gt;
&lt;li&gt;Data Scientist - this role is the worst defined. This role is most commonly found in non-tech firms, but not always. There tends to be a combination of the top 3, but most of the algorithms and software tends to be off the shelf. This job in many ways tends to be a mixture of software engineer and domain expert, or a progression of the Data Analyst. Going beyond off the shelf requires tends to require a full ML team, and the Data Scientists here tend to be using internally built tools and techniques and reporting to the central team developing algorithms for problems. This role is still in flux and will likely be for a while. Any company of significant size will start moving towards ML engineers with math expertise and Data Scientists with domain expertise.&lt;/li&gt;
&lt;/ol&gt;</content><category term="interview"></category><category term="ds"></category><category term="advice"></category><category term="interviews"></category></entry></feed>